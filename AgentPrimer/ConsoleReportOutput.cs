// Code authored by Dean Edis (DeanTheCoder).
// Anyone is free to copy, modify, use, compile, or distribute this software,
// either in source code form or as a compiled binary, for any non-commercial
// purpose.
//
// If you modify the code, please retain this copyright header,
// and consider contributing back to the repository or letting us know
// about your modifications. Your contributions are valued!
//
// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND.

using System.Text;
using AgentPrimer.Utilities;
using DTC.Core.Extensions;
using DTC.Core.Markdown;

namespace AgentPrimer;

/// <summary>
/// Renders repository reports and errors to the sb.
/// </summary>
internal sealed class ConsoleReportOutput
{
    private readonly bool m_agentMode;
    
    public ConsoleReportOutput(bool agentMode)
    {
        m_agentMode = agentMode;
    }
    
    public int WriteRepositoryNotFound()
    {
        Console.WriteLine("This script must be run from a git repository.");
        return 1;
    }

    public int WriteGitUnavailable()
    {
        Console.WriteLine("Git is not installed on this machine.");
        return 1;
    }

    public int WriteReport(PrimerReport report)
    {
        var sb = new StringBuilder();
        var consoleMarkdown = new ConsoleMarkdown();

        sb.AppendLine("# Repository Overview");
        sb.AppendLine("_An overview of the current repository and its related projects, generated by [AgentPrimer](https://github.com/deanthecoder/AgentPrimer)._");

        if (m_agentMode)
        {
            sb.AppendLine("## Agent Instructions (Overview)");
            sb.AppendLine("- Read this report top-to-bottom to understand the repository structure, technologies, and conventions.");
            sb.AppendLine("- Look for **Agent note** callouts embedded in specific sections; they contain targeted guidance.");
            sb.AppendLine("- Keep context usage lean: prefer summaries and interfaces over ingesting full source files.");
            sb.AppendLine("- Match the English style as reported below.");
            sb.AppendLine("- Prefer existing frameworks, tests, and naming conventions shown here.");
        }
        
        sb.AppendLine("## Path");
        sb.AppendLine($"  `{report.RepositoryPath}`");

        if (report.Repositories.Count > 0)
        {
            sb.AppendLine($"## Repositories ({report.Repositories.Count})");
            AppendAgentNotes(sb, "Sub-modules and sibling repositories often expose reusable libraries (e.g., extension methods, utilities). Cross-reference these before re-implementing.");
            foreach (var repository in report.Repositories)
            {
                sb.AppendLine($"  - {repository.Url} {(repository.IsSubmodule ? "(Submodule)" : string.Empty)}  ");
                sb.AppendLine($"    {repository.Description}");
            }
        }

        sb.AppendLine("## Stats");
        var statsNotes = new List<string>
        {
            "Match the projectâ€™s English style for identifiers, comments, and documentation."
        };

        string languageSummary = null;
        if (report.LanguageBreakdown.Count > 0)
        {
            statsNotes.Add("Use the dominant language(s) and idioms when proposing code.");
            languageSummary = report.LanguageBreakdown
                .Select(o => $"{o.Key} ({o.Value:P0})")
                .ToCsv()
                .Replace(",", " | ", StringComparison.Ordinal);
        }

        AppendAgentNotes(sb, statsNotes.ToArray());

        sb.AppendLine($"* Files      : {report.SourceFileCount}");

        if (languageSummary is null)
        {
            sb.AppendLine("* Languages  : none");
        }
        else
        {
            sb.AppendLine($"* Languages  : {languageSummary}");
        }
        sb.AppendLine($"* English    : {report.EnglishPreference} English");

        if (report.LargestSourceFiles.Length > 0)
        {
            sb.AppendLine($"## Largest Source Files ({report.LargestSourceFiles.Length})");
            AppendAgentNotes(sb, "Avoid ingesting very large files wholesale; focus on public types, key methods, and file headers to preserve tokens.");
            foreach (var file in report.LargestSourceFiles)
                sb.AppendLine($"* {file.Size.ToSize(),-12} : `{file.Path}`");
        }

        sb.AppendLine($"## NuGet ({report.NugetPackages.Count})");
        AppendAgentNotes(sb, "Prefer solutions using the listed packages and frameworks; avoid introducing new technologies without justification.");
        if (report.NugetPackages.Count == 0)
        {
            sb.AppendLine("  none");
        }
        else
        {
            var names = report.NugetPackages
                .Select(i => $"`{i.Name}`")
                .OrderBy(n => n, StringComparer.OrdinalIgnoreCase)
                .ToArray();

            ConsoleSectionWriter.PrintWrappedList(sb, names, indent: "  ", maxWidth: 80, separator: " | ");
        }

        sb.AppendLine("## Preferences");
        AppendAgentNotes(sb, "Align with nullable settings, test framework/assertion style, mocking approach, and UI patterns already used in this codebase.");
        if (report.NullableReferenceTypesEnabled.HasValue)
            sb.AppendLine($"* Nullable : {(report.NullableReferenceTypesEnabled.Value ? "enabled" : "disabled")}");
        if (report.UnitTestFramework.HasValue)
            sb.AppendLine($"* Tests    : {report.UnitTestFramework.Value}");
        if (report.MockingFramework.HasValue)
            sb.AppendLine($"* Mocking  : {report.MockingFramework.Value}");
        if (report.PreferredUiLibraries.Length > 0)
            sb.AppendLine($"* UI       : {report.PreferredUiLibraries.Select(o => o.ToString()).ToCsv(addSpace: true)}");

        if (report.InternalProjects.Count > 0)
        {
            var utilities = report.InternalProjects.Where(o => o.ReferenceCount > 0).ToArray();
            var topLevel = report.InternalProjects.Where(o => o.ReferenceCount == 0).ToArray();

            if (utilities.Length > 0 || topLevel.Length > 0)
            {
                sb.AppendLine("## Projects");
                AppendAgentNotes(sb, "Treat internal projects as core dependencies; follow their naming, layering, and public APIs when extending functionality.");
                if (topLevel.Length > 0)
                {
                    sb.AppendLine("### Top-level");
                    foreach (var project in topLevel)
                        sb.AppendLine($"* `{project.Name}` ({project.TargetFramework})");
                }

                if (utilities.Length > 0)
                {
                    sb.AppendLine("### Internal");
                    foreach (var library in utilities)
                        sb.AppendLine($"* `{library.Name}` ({library.TargetFramework}) [refs:{library.ReferenceCount}]");
                }
            }
        }

        if (report.ReadmeFiles.Count > 0)
        {
            sb.AppendLine($"## READMEs ({report.ReadmeFiles.Count})");
            AppendAgentNotes(sb, "READMEs often contain background, design intent, and setup steps; consult them when modifying code or documentation.");
            foreach (var readme in report.ReadmeFiles)
                sb.AppendLine($"* `{readme}`");
        }

        var reportContent = sb.ToString();

        if (m_agentMode)
        {
            var agentsPath = Path.Combine(report.RepositoryPath, "agents.md");
            File.WriteAllText(agentsPath, reportContent);
            Console.WriteLine($"Agent instructions written to repo root: {agentsPath}");
        }
        else
        {
            consoleMarkdown.Write(reportContent);
        }

        return 0;
    }

    private void AppendAgentNotes(StringBuilder sb, params string[] notes)
    {
        if (!m_agentMode || notes == null)
            return;

        foreach (var note in notes)
            sb.AppendLine($"> **Agent note:** {note}");
        
        sb.AppendLine();
    }
}
